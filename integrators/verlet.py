import numpy as np
from scipy.special import erfinv
import h5py
import params

"""Here we shall re-assign values as set in params"""

no_of_particles      = params.no_of_particles
choice_integrator    = params.choice_integrator
collision_operator   = params.collision_operator

plot_spatial_temperature_profile = params.plot_spatial_temperature_profile

if(plot_spatial_temperature_profile == "true"):
  x_zones_temperature = params.x_zones_temperature
  y_zones_temperature = params.y_zones_temperature

elif(collision_operator == "potential-based"):
  potential_steepness     = params.potential_steepness
  potential_amplitude     = params.potential_amplitude
  order_finite_difference = params.order_finite_difference

elif(collision_operator == "montecarlo"):
  x_zones_montecarlo = params.x_zones_montecarlo
  y_zones_montecarlo = params.y_zones_montecarlo
  
mass_particle      = params.mass_particle
boltzmann_constant = params.boltzmann_constant
T_initial          = params.T_initial
wall_condition_x   = params.wall_condition_x
wall_condition_y   = params.wall_condition_y
wall_condition_z   = params.wall_condition_z

if(wall_condition_x == "thermal"):
  T_left_wall  = params.T_left_wall
  T_right_wall = params.T_right_wall

if(wall_condition_y == "thermal"):
  T_top_wall = params.T_top_wall
  T_bot_wall = params.T_bot_wall

if(wall_condition_z == "thermal"):
  T_front_wall = params.T_front_wall
  T_back_wall  = params.T_back_wall

fields_enabled   = params.fields_enabled

if(fields_enabled == "true"):
  spread            = params.spread
  ghost_cells       = params.ghost_cells
  speed_of_light    = params.speed_of_light
  charge            = params.charge
  x_zones_field     = params.x_zones_field
  y_zones_field     = params.y_zones_field

left_boundary    = params.left_boundary
right_boundary   = params.right_boundary
length_box_x     = params.length_box_x

bottom_boundary  = params.bottom_boundary
top_boundary     = params.top_boundary
length_box_y     = params.length_box_y

back_boundary    = params.back_boundary
front_boundary   = params.front_boundary
length_box_z     = params.length_box_z

# Here we complete import of all the variable from the parameters file

"""
We shall be implementing the velocity Verlet algorithm:
For this, we shall be using a staggered temporal grid
It may be represented as follows:

|-o-|-o-|-o-|---

In the above diagram, the notations used may be explained as follows

*) |---| = o-|-o = dt, and

*) |-o = o-| = dt/2

Now we need to solve for the positions and velocities on this staggered grid.
We shall be using the "kick-drift-kick" variant of this integrator

We need to solve the equations:

dx/dt   = v ---(1)
m dv/dt = F ---(2)

The implementation of the integrator is as follows:
Denoting integer times "|" by "n", and half-integer time "o" by "n+1/2",
Let us assume that the data that is passed to the Verlet integrator is at time-N
Thus initially the data is x^N and v^N

Now we shall evaluate the value of velocity at the half time step.
Basically moving forward in the grid by |-o

v^{N+1/2} = v^{N} + F{x^N}/m * (dt/2)

The above force is computed as a result of the field generated by the particles at time level N
Once we have the half step velocity, we may update the value of distance at time level N+1

x^{N+1} = x^N + v^{N+1/2}*dt

The N+1 time level velocity may then be determined by

v^{N+1} = v^{N+1/2} + F{x^{N+1}}/m * (dt/2)

"""

def integrator(x_coords, y_coords, z_coords,\
               vel_x   , vel_y   , vel_z   ,\
               dt, potential_steepness = 0
              ):

  x_coords_new = x_coords
  y_coords_new = y_coords
  z_coords_new = z_coords
  
  if(collision_operator == "potential-based"):
  
    x_coords = x_coords * np.ones((no_of_particles,no_of_particles),dtype=np.float) #x^{N}
    x_coords = x_coords - np.transpose(x_coords)                                    #x^{N}

    y_coords = y_coords * np.ones((no_of_particles,no_of_particles),dtype=np.float) #y^{N}
    y_coords = y_coords - np.transpose(y_coords)                                    #y^{N}

    z_coords = z_coords * np.ones((no_of_particles,no_of_particles),dtype=np.float) #z^{N}
    z_coords = z_coords - np.transpose(z_coords)                                    #z^{N}

    from collision_operators.potential import potential_gradient, potential

    distance = np.sqrt(x_coords**2 + y_coords**2 + z_coords**2) # distance^{N}
    vector   = np.array([x_coords,y_coords,z_coords])       # vector^{N}
    nvector  = np.nan_to_num(vector/dist)                   # normalizedvector{N}
    
    force   = potential_gradient(potential_steepness, dist, order_finite_difference) # F^{N}
    force_x = np.sum(force * nvector[0], axis=1)
    force_y = np.sum(force * nvector[1], axis=1)
    force_z = np.sum(force * nvector[2], axis=1)

    vel_x = vel_x + 0.5*(force_x/mass_particle)*dt #v_{x}^{N+1/2}
    vel_y = vel_y + 0.5*(force_y/mass_particle)*dt #v_{y}^{N+1/2}
    vel_z = vel_z + 0.5*(force_z/mass_particle)*dt #v_{y}^{N+1/2}
  
  x_coords_new = x_coords_new + vel_x*dt #x^{N+1}
  y_coords_new = y_coords_new + vel_y*dt #y^{N+1}
  z_coords_new = z_coords_new + vel_z*dt #z^{N+1}

  x_coords = x_coords_new.copy() #x^{N+1}
  y_coords = y_coords_new.copy() #y^{N+1}
  z_coords = z_coords_new.copy() #z^{N+1}

  if(collision_operator == "potential-based"):

    x_coords = x_coords * np.ones((no_of_particles,no_of_particles),dtype=np.float) #x^{N+1}
    x_coords = x_coords - np.transpose(x_coords)                               #x^{N+1}

    y_coords = y_coords * np.ones((no_of_particles,no_of_particles),dtype=np.float) #y^{N+1}
    y_coords = y_coords - np.transpose(y_coords)                               #y^{N+1}

    z_coords = z_coords * np.ones((no_of_particles,no_of_particles),dtype=np.float) #z^{N+1}
    z_coords = z_coords - np.transpose(z_coords)                               #z^{N+1}

    from collision_operators.potential import potential_gradient, potential
    
    distance = np.sqrt(x_coords**2+y_coords**2+z_coords**2) # distance^{N+1}
    vector   = np.array([x_coords,y_coords,z_coords])       # vector^{N+1}
    nvector  = np.nan_to_num(vector/distance)                                  # normalizedvector{N+1}
    
    force   = potential_gradient(potential_steepness, dist, order_finite_difference) # F^{N+1}
    force_x = np.sum(force * nvector[0], axis=1)
    force_y = np.sum(force * nvector[1], axis=1)
    force_z = np.sum(force * nvector[2], axis=1)

    vel_x = vel_x + 0.5*(force_x/mass_particle)*dt #v_{x}^{N+1}
    vel_y = vel_y + 0.5*(force_y/mass_particle)*dt #v_{y}^{N+1}
    vel_z = vel_z + 0.5*(force_z/mass_particle)*dt #v_{z}^{N+1}

  return(x_coords_new, y_coords_new, z_coords_new,\
         vel_x       , vel_y       , vel_z        \
        )