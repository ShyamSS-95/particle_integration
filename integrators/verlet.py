from modules import *
from simulation_parameters import *

"""
We shall be implementing the velocity Verlet algorithm:
For this, we shall be using a staggered temporal grid
It may be represented as follows:

|-o-|-o-|-o-|---

In the above diagram, the notations used may be explained as follows

*) |---| = o-|-o = dt, and

*) |-o = o-| = dt/2

Now we need to solve for the positions and velocities on this staggered grid.
We shall be using the "kick-drift-kick" variant of this integrator

We need to solve the equations:

dx/dt = v   ---(1)
m dv/dt = F ---(2)

The implementation of the integrator is as follows:
Denoting integer times "|" by "n", and half-integer time "o" by "n+1/2",
Let us assume that the data that is passed to the Verlet integrator is at time-N
Thus initially the data is x^N and v^N

Now we shall evaluate the value of velocity at the half time step.
Basically moving forward in the grid by |-o

v^{N+1/2} = v^{N} + F{x^N}/m * (dt/2)

The above force is computed as a result of the field generated by the particles at time level N
Once have the half step velocity we may update the value of distance at time level N+1

x^{N+1} = x^N + v^{N+1/2}*dt

The N+1 time level velocity may then be determined by

v^{N+1} = v^{N+1/2} + F{x^{N+1}}/m * (dt/2)

"""

def integrator(initial_conditions,dt,potential_steepness = 0):

  x_coordinates = initial_conditions[0:no_of_particles].copy()                     #x^{N}
  y_coordinates = initial_conditions[no_of_particles:2*no_of_particles].copy()     #y^{N}
  velocity_x    = initial_conditions[2*no_of_particles:3*no_of_particles].copy()   #v_x^{N}
  velocity_y    = initial_conditions[3*no_of_particles:4*no_of_particles].copy()   #v_y^{N}

  if(simulation_dimension == 3):

    z_coordinates = initial_conditions[2*no_of_particles:3*no_of_particles].copy()   #z^{N}

    velocity_x    = initial_conditions[3*no_of_particles:4*no_of_particles].copy()   #v_x^{N}
    velocity_y    = initial_conditions[4*no_of_particles:5*no_of_particles].copy()   #v_y^{N}
    velocity_z    = initial_conditions[5*no_of_particles:6*no_of_particles].copy()   #v_z^{N}


  # Manipulating data to implement vectorization
  
  if(collision_operator == 2):
  
    x_coordinates = x_coordinates * np.ones((no_of_particles,no_of_particles),dtype=np.float) #x^{N}
    x_coordinates = x_coordinates - np.transpose(x_coordinates)                               #x^{N}

    y_coordinates = y_coordinates * np.ones((no_of_particles,no_of_particles),dtype=np.float) #y^{N}
    y_coordinates = y_coordinates - np.transpose(y_coordinates)                               #y^{N}

    if(simulation_dimension == 3):

      z_coordinates = z_coordinates * np.ones((no_of_particles,no_of_particles),dtype=np.float) #z^{N}
      z_coordinates = z_coordinates - np.transpose(z_coordinates)                               #z^{N}


    from collision_operators.potential import potential_gradient, potential
    
    distance = np.sqrt(x_coordinates**2+y_coordinates**2) # distance^{N}
    vector   = np.array([x_coordinates, y_coordinates])   # vector^{N}
    nvector  = np.nan_to_num(vector/dist)                 # normalizedvector{N}
    
    force    = potential_gradient(potential_steepness, distance, order_finite_difference) # F^{N}
    force_x  = np.sum(force * nvector[0], axis=1)
    force_y  = np.sum(force * nvector[1], axis=1)
  
    if(simulation_dimension == 3):

      distance = np.sqrt(x_coordinates**2+y_coordinates**2+z_coordinates**2) # distance^{N}
      vector   = np.array([x_coordinates,y_coordinates,z_coordinates])       # vector^{N}
      nvector  = np.nan_to_num(vector/dist)                                  # normalizedvector{N}
      
      force   = potential_gradient(potential_steepness, dist, order_finite_difference) # F^{N}
      force_x = np.sum(force * nvector[0], axis=1)
      force_y = np.sum(force * nvector[1], axis=1)
      force_z = np.sum(force * nvector[2], axis=1)

    velocity_x = velocity_x + 0.5*(force_x/mass_particle)*dt #v_{x}^{N+1/2}
    velocity_y = velocity_y + 0.5*(force_y/mass_particle)*dt #v_{y}^{N+1/2}

    if(simulation_dimension == 3):
    
      velocity_z = velocity_z + 0.5*(force_z/mass_particle)*dt #v_{y}^{N+1/2}

    
  x_coordinates = initial_conditions[0:no_of_particles].copy()                 #x^{N}          
  y_coordinates = initial_conditions[no_of_particles:2*no_of_particles].copy() #y^{N}
  velocity_x    = initial_conditions[2*no_of_particles:3*no_of_particles].copy()   #v_x^{N}
  velocity_y    = initial_conditions[3*no_of_particles:4*no_of_particles].copy()   #v_y^{N}

  x_coordinates_new = x_coordinates + velocity_x*dt #x^{N+1}
  y_coordinates_new = y_coordinates + velocity_y*dt #y^{N+1}

  if(simulation_dimension == 3):

    z_coordinates     = initial_conditions[2*no_of_particles:3*no_of_particles].copy() #z^{N}
    z_coordinates_new = z_coordinates + velocity_z*dt                                  #z^{N+1}

  x_coordinates = x_coordinates_new.copy()     #x^{N+1}
  y_coordinates = y_coordinates_new.copy()     #y^{N+1}

  if(simulation_dimension == 3):

    z_coordinates = z_coordinates_new.copy()   #z^{N+1}

  if(collision_operator == 2):

    x_coordinates = x_coordinates * np.ones((no_of_particles,no_of_particles),dtype=np.float) #x^{N+1}
    x_coordinates = x_coordinates - np.transpose(x_coordinates)                               #x^{N+1}

    y_coordinates = y_coordinates * np.ones((no_of_particles,no_of_particles),dtype=np.float) #y^{N+1}
    y_coordinates = y_coordinates - np.transpose(y_coordinates)                               #y^{N+1}

    if(simulation_dimension == 3):

      z_coordinates = z_coordinates * np.ones((no_of_particles,no_of_particles),dtype=np.float) #z^{N+1}
      z_coordinates = z_coordinates - np.transpose(z_coordinates)                               #z^{N+1}



    from collision_operators.potential import potential_gradient, potential
    
    distance = np.sqrt(x_coordinates**2+y_coordinates**2) # distance^{N+1}
    vector   = np.array([x_coordinates, y_coordinates])   # vector^{N+1}
    nvector  = np.nan_to_num(vector/dist)                 # normalizedvector{N+1}
    
    force    = potential_gradient(potential_steepness, distance, order_finite_difference) # F^{N+1}
    force_x  = np.sum(force * nvector[0], axis=1)
    force_y  = np.sum(force * nvector[1], axis=1)
  
    if(simulation_dimension == 3):

      distance = np.sqrt(x_coordinates**2+y_coordinates**2+z_coordinates**2) # distance^{N+1}
      vector   = np.array([x_coordinates,y_coordinates,z_coordinates])       # vector^{N+1}
      nvector  = np.nan_to_num(vector/dist)                                  # normalizedvector{N+1}
      
      force   = potential_gradient(potential_steepness, dist, order_finite_difference) # F^{N+1}
      force_x = np.sum(force * nvector[0], axis=1)
      force_y = np.sum(force * nvector[1], axis=1)
      force_z = np.sum(force * nvector[2], axis=1)

    velocity_x = velocity_x + 0.5*(force_x/mass_particle)*dt #v_{x}^{N+1}
    velocity_y = velocity_y + 0.5*(force_y/mass_particle)*dt #v_{y}^{N+1}

    if(simulation_dimension == 3):
    
      velocity_z = velocity_z + 0.5*(force_z/mass_particle)*dt #v_{y}^{N+1}

  
  if(simulation_dimension == 2):
    next_step = np.concatenate([x_coordinates_new, y_coordinates_new, velocity_x, velocity_y],axis=0)

  else:
    next_step = np.concatenate([x_coordinates_new, y_coordinates_new, z_coordinates_new, velocity_x, velocity_y,velocity_z],axis=0)

  return(next_step)